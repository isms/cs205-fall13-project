from settings import *


def evaluate_placement(placements):
    """
    Evaluate the non-linear fitness of a solution generated by the ILP model.

    Because of the format of the input files generated by the school, this
    method contains quite a few `for` loops and `if/elif/else` sanity checks.
    """

    # initialize scores
    friend_score = 0
    no_friend_penalty = 0
    low_enemy_penalty = 0
    high_enemy_penalty = 0
    low_class_not_ok_penalty = 0
    high_class_not_ok_penalty = 0
    gender_penalty = 0
    class_size_penalty = 0
    low_teacher_rec_score = 0
    high_teacher_rec_score = 0
    troublemaker_penalty = 0
    geographic_penalty = 0

    # initialize other values
    class_sizes = np.zeros(NUM_CLASSES)
    males_per_class = np.zeros(NUM_CLASSES)

    # setup a dictionary to make it very quick to access a student's placement
    placement_dict = {}
    for elem in placements:
        placement_dict[elem[0]] = elem[1]

    # get size of each class
    for elem in placements:
        class_sizes[elem[1] - 1] += 1

    # score parent request components
    for elem in parent_requests:
        placement = placement_dict[elem[0]]
        individual_friend_score = 0
        has_requests = False

        for i in CLASSES:
            if not np.isnan(elem[i + 1]):
                has_requests = True
                if placement == placement_dict[elem[i + 1]]:
                    individual_friend_score += 50

        if has_requests and individual_friend_score == 0:
            no_friend_penalty -= 500

        friend_score += individual_friend_score

    # score enemy components
    for elem in enemies:
        placement = placement_dict[elem[0]]
        for i in range(1, 9, 2):
            if (not np.isnan(elem[i])) and (placement == placement_dict[elem[i]]):
                if elem[i + 1] == 1:
                    low_enemy_penalty -= 200
                elif elem[i + 1] == 2:
                    high_enemy_penalty -= 500
                else:
                    raise RuntimeError('Problem with enemy input file.')

    # score requests for specific teachers
    for elem in ok_classes:
        placement = placement_dict[elem[0]]
        if elem[placement] == 0:
            if elem[5] == 0:
                low_class_not_ok_penalty -= 200
            elif elem[5] == 1:
                high_class_not_ok_penalty -= 500
            else:
                raise RuntimeError('Problem with teacher request input file.')

    # get number of males in each class and assess gender penalties
    for elem in gender:
        placement = placement_dict[float(elem[0])]
        if elem[1] == "M":
            males_per_class[placement - 1] += 1.0

    for i in CLASSES:
        temp = males_per_class[i] / 0.67 - class_sizes[i]
        if temp > 0:
            gender_penalty -= 350 * temp

    # assess class size penalty
    min_class_size = np.min(class_sizes)
    max_class_size = np.max(class_sizes)
    class_size_difference = max_class_size - min_class_size
    if class_size_difference > 1:
        class_size_penalty -= 500 * class_size_difference

    # assess points for fulfilling teacher recommendations
    for elem in teacher_recs:
        placement = placement_dict[elem[0]]
        for i in range(1, 11, 2):
            if (not np.isnan(elem[i])) and (placement == placement_dict[elem[i]]):
                if elem[i + 1] == 1:
                    low_teacher_rec_score += 50
                elif elem[i + 1] == 2:
                    high_teacher_rec_score += 400
                else:
                    RuntimeError('Problem with teacher recommendation input file.')

    #assess troublemaker penalty
    troublemaker_count = np.zeros(NUM_CLASSES)
    for elem in troublemakers:
        if elem[1] == 1:
            troublemaker_count[placement_dict[elem[0]] - 1] += 1

    if max(troublemaker_count) > MAX_NUM_TROUBLEMAKERS_PER_CLASS:
        troublemaker_penalty -= (max(troublemaker_count) - MAX_NUM_TROUBLEMAKERS_PER_CLASS) * 45

    # assess geographic penalties
    location_dict = {}
    for elem in np.unique(locations[:, 1]):
        for i in range(NUM_CLASSES):
            location_dict[elem + "F" + str(i + 1)] = 0
            location_dict[elem + "M" + str(i + 1)] = 0

    for i, elem in enumerate(locations):
        placement = int(placement_dict[int(elem[0])])
        location_dict[elem[1] + gender[i][1] + str(placement)] += 1

    for key in location_dict.keys():
        if location_dict[key] == 1:
            geographic_penalty -= 45

    objective_function_value = (class_size_penalty + gender_penalty + friend_score +
                                no_friend_penalty + low_enemy_penalty +
                                high_enemy_penalty + low_class_not_ok_penalty +
                                high_class_not_ok_penalty + low_teacher_rec_score +
                                high_teacher_rec_score + troublemaker_penalty +
                                geographic_penalty)

    return objective_function_value